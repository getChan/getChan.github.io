---
title: "스택 메모리"
excerpt: "스택 메모리 in C"

categories:
  - cs
tags:
  - c
  - cs
last_modified_at: 2021-07-14T08:06:00-05:00
---

**C의 기본 자료형 변수는 스택 메모리를 차지한다.**

- `new` 키워드 없이 사용할 수 있었던 이유. 스택 메모리에 할당되기 때문.
- 기본 자료형을 함수 매개변수로 전달하면 스택에 복사본을 만듦 -> 값형
- 스택 메모리를 빌리고 반환할 때마다 언제나 빈 공간 없이 차곡차곡 쌓여 있음(실제 메모리에서 순서대로 쌓이지는 않음. 가상 메모리로 인해)
  - 정확히 함수 호출이 몇 바이트를 사용할지 알 수 있음
- `new`로 만든 데이터는 heap 메모리에 할당됨
  - 메모리에 구멍이 뚫릴 수 있음

C 배열은 참조형이 아니다. (char ch[64]) `new`로 만든 데이터가 아님.

참고로 java에서 배열은 기본적으로 참조형이다. 

- https://www.geeksforgeeks.org/array-primitive-type-object-java/

어셈블리 언어에서 사용하는 용어

- ESP : Extended Stack Pointer
  - 현재 스택 포인터
- EBP : Extended Base Pointer
  - 현재 스택 프레임의 기본(첫) 주소(입구)
- 스택 프레임
  - 각 함수가 사용하는 스택 메모리의 범위

스레드의 경우 각각 별도의 스택 영역을 가지는데, 메모리의 할당은 스레드가 생성하는 시점에 할당한다.

**너무 큰 데이터는 스택에 넣으면 안됩니다.**

- stackOverFlow가 발생할 수 있음.
- 이럴 경우 동적 메모리 할당(`new`)

재귀 함수에서 스택오버플로 나는 이유

- 함수 호출때마다 해당 함수 스택 프레임만큼의 바이트를 할당받음
- 무한으로 호출하다 보면 스택 메모리 공간을 다 써버림.

`sizeof(arg)`와 배열의 총 바이트 수

- `sizeof()`가 매개변수로 들어온 배열의 총 바이트 수를 반환할 수 있으려면
- 그 배열의 모든 요소가 스택에 전부 복사되어야 함

그러나 ! 함수는 호출자가 누구든 **딱 정해진 수와 크기의 매개변수**가 들어온단 가정으로 동작

따라서 ! 배열을 매개변수로 전달할 때는 실제 모든 요소를 스택에 넣지 않음

- 대신 배열의 시작 위치(주소)를 스택에 넣어줌
- 주소의 크기 = 포인터 데이터형의 크기
- 32비트 플랫폼에서는 4바이트, 64비트에서는 8바이트
- 그래서 `sizeof()`를 하면 4바이트가 나온 것.



# 참고

POCU 강의 ["C 언매니지드 프로그래밍"](https://pocu.academy/ko/Courses/COMP2200)
