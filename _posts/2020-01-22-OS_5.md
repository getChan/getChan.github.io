---
title: "운영체제(5)-CPU 스케줄링:man_factory_worker:"
excerpt: "컴퓨터공학을 정리해봅니다."

categories:
  - cs
tags:
  - study
  - computer science
  - os
last_modified_at: 2020-01-16T08:06:00-05:00
---

> 책 `<운영체제와 정보기술의 원리>, 반효경` 을 읽고 정리한 내용입니다
>
> 이미지 출처 : [`종난아 공부하자!` 블로그]([https://jongnan.tistory.com/entry/CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81](https://jongnan.tistory.com/entry/CPU-스케줄링))
>
> [운영체제(1) - 개요](/cs/OS_1)
>
> [운영체제(2) - 컴퓨터 시스템의 동작 원리](/cs/OS_2)
>
> [운영체제(3) - 인터럽트의 원리](/cs/OS_3)
>
> [운영체제(4) - 프로세스 관리](/cs/OS_4)

프로그램이 시작되어 메모리에 올라가면, 프로그램 카운터(PC)라는 이름의 레지스터가 현재 CPU에서 수행할 코드의 메모리 주소값을 가지고 있게 된다. 그러면 CPU는 프로그램 카운터가 가리키는 주소의 기계어 명령을 하나씩 수행하게 된다.

기계어 명령은 크게 세가지로 나눌 수 있다.

- CPU내에서 실행되는 명령 
  - ex. `ADD`
  - 명령의 수행 속도가 매우 빠르다
  - 일반 명령
- 메모리 접근을 필요로 하는 명령
  - ex. `Load` / `Store`
  - CPU내에서 수행되는 명령보다는 시간이 걸리지만, 비교적 짧은 시간에 수행할 수 있는 명령 
  - 일반 명령
- 입출력을 동반하는 명령
  - CPU나 메모리 접근 명령보다 꽤 많은 시간이 소요된다.
  - 특권 명령



**사용자 프로그램이 수행되는 과정은 CPU작업과 I/O 작업의 반복으로 구성된다.**

**CPU 버스트**

- 사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계

**I/O 버스트**

- I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 비교적 느린 단계

<img src="https://t1.daumcdn.net/cfile/tistory/99ED79435B04EEDC36" alt="img" style="zoom:50%;" />

각 프로그램마다 CPU 버스트와 I/O 버스트가 차지하는 비율이 균일하지는 않다.

CPU 바운드 프로세스

- I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스
- 계산 위주의 프로그램

I/O 바운드 프로세스

- I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스
- 대화형 프로그램



CPU버스트가 균일하지 않은 다양한 프로그램이 공존하므로 효율적인 CPU 스케줄링 기법이 반드시 필요하다.

컴퓨터 시스템 내에서는 CPU를 한번에 오래 사용하기보다는 잠깐 사용하고 I/O 작업을 수행하는 프로세스들이 많다. (대화형 작업)

이러한 대화형 작업은 CPU의 빠른 서비스를 필요로 한다. 따라서 CPU 스케줄링 시 CPU 버스트가 짧은 프로세스. 즉 I/O 바운드 프로세스에게 우선순위를 높여주는 것이 바람직하다. 이러한 스케줄링은 I/O 장치의 효율성을 높이는 효과도 얻을 수 있다.

# CPU 스케줄러

준비 상태에 있는 프로세스 중 어떠한 프로세스에게 CPU를 할당할지를 결정하는 운영체제의 코드.

CPU 스케줄링의 발생 상황

1. run state에 있던 프로세스가 I/O 요청 등에 의해 Blocked State로 바뀌는 경우

   비선점형 스케줄링

2. run state에 있던 프로세스가 타이머 인터럽트 발생에 의해 ready state로 바뀌는 경우

   선점형 스케줄링

3. I/O 요청으로 blocked state에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스의 상태가 ready state로 바뀌는 경우(직전 프로세스가 아닌 I/O가 완료된 프로세스에게 CPU할당하는 문맥교환이 일어나는 경우.)

   선점형 스케줄링

4. CPU에서 run state에 있는 프로세스가 terminated 되는 경우

   비선점형 스케줄링

비선점형 스케줄링 : CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는다.

선점형 스케줄링 : 프로세스가 CPU를 계속 사용하기 원하더라도 강제로 빼앗을 수 있다.

# 디스패처

CPU 스케줄러를 통해 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경 설정을 하는 커널 모듈

디스패처는 현재 수행중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정을 수행한다.

## 디스패치 지연 시간

- 디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간.
- 대부분은 문맥 교환 오버헤드에 해당된다.

# 스케줄링의 성능 평가

**시스템 관점의 지표**로는 CPU활용도와 처리량이 있으며, **사용자 관점의 지표**로는 소요 시간, 대기 시간, 응답 시간 등이 있다. 지표의 정의는 다음과 같다.

- **CPU 활용도** (CPU utilization)
  - 전체 시간 중 CPU가 명령을 수행한 시간의 비율
- **처리량** (throughput)
  - 주어진 시간 동안 CPU 버스트를 완료한 프로세스의 개수
  - CPU 버스트가 짧은 프로세스에게 우선 CPU 할당하면 처리량은 증가한다.
- **소요 시간** (turnaround time)
  - 프로세스가 CPU 요청한 시점부터 CPU 버스트가 끝날 때까지 걸린 시간
  - **CPU버스트가 준비 큐에서 기다린 시간과 실제 CPU를 사용한 시간의 합**
  - 소요 시간은 프로그램 전체가 아닌 CPU 버스트의 수만큼 각각 별도로 측정
- **대기 시간** (waiting time)
  - 프로세스가 CPU 버스트 기간 중 준비 큐에서 기다린 시간의 합
  - **한 번의 CPU 버스트 중에도 준비 큐에서 기다린 시간이 여러 번 발생할 수 있다.**(시분할 시스템)
- **응답 시간** (response time)
  - 프로세스가 CPU요청 시점부터 처음으로 CPU를 얻을 때까지 기다린 시간
  - **타이머 인터럽트가 빈번히 발생할수록 응답 시간이 향상된다.**
  - 대화형 시스템에 적합한 성능 척도

> **중국집 예시**
>
> 활용도 - 전체 시간 중 주방장이 일한 시간의 비율
>
> 처리량 - 주방장이 주어진 시간 동안 몇 명의 손님에게 요리를 주었는지
>
> 소요시간 - 손님이 중국집에 들어와 음식을 다 먹고 나가기까지 소요된 총 시간
>
> 대기시간 - 중국집에 들어와 순수하게 음식을 기다린 시간, 음식이 조금씩 여러번 나왔다면 각각의 음식이 나오기까지 기다린 시간을 합한 것
>
> 응답시간 - 최초의 음식이 나오기까지 기다린 시간

# 스케줄링 알고리즘