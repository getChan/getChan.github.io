---
title: "운영체제(6)-메모리 관리"
excerpt: "컴퓨터공학을 정리해봅니다."

categories:
  - cs
tags:
  - study
  - computer science
  - os
last_modified_at: 2020-02-20T08:06:00-05:00
---

> 책 `<운영체제와 정보기술의 원리>, 반효경` 을 읽고 정리한 내용입니다
>
> [운영체제(1) - 개요](/cs/OS_1)
>
> [운영체제(2) - 컴퓨터 시스템의 동작 원리](/cs/OS_2)
>
> [운영체제(3) - 인터럽트의 원리](/cs/OS_3)
>
> [운영체제(4) - 프로세스 관리](/cs/OS_4)
>
> [운영체제(5) - CPU스케줄링](/cs/OS_5)



주소(address)란 서로 다른 위치를 구분하기 위해 사용하는 일련의 숫자이다.

컴퓨터에서는 Byte단위로 메모리 주소를 부여한다. 따라서 32비트 주소 체계를 사용하면 $2^{32}$만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다.

보통 4KB(=$2^{12}$) 단위로 묶어서 페이지라는 하나의 행정 구역을 만들게 된다. 페이지 하나의 크기가 $2^{12}$바이트이므로 페이지 내에서의 바이트별 위치 구분을 위해서는 12비트가 필요하다(페이지 간 구별을 위해서는 $2^{32} / 2^{12} = 2^{20}$, 20비트가 필요)



# 주소 바인딩

프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소 공간이 생성된다. 이 주소를 **논리적 주소** 혹은 가상 주소라고 부른다.

논리적 주소는 각 프로세스마다 독립적으로 할당되며 0번지부터 시작된다.

반면, 물리적 주소는 물리적 주소에 실제로 올라가는 위치를 말한다.

프로세스의 논리적 주소를 물리적 주소로 매핑하는 작업을 **주소 바인딩**이라고 한다.

주소 바인딩의 방식

1. 컴파일 타임 바인딩

	- 물리적 메모리 주소가 **프로그램을 컴파일할 때 결정**되는 주소 바인딩 방식
	- 프로그램이 적재된 물리 메모리의 위치를 바꾸려면 컴파일을 다시 해야 한다.
	
2. 로드 타임 바인딩

   - **프로그램의 실행이 시작**될 때 물리 메모리 주소가 결정되는 방식
   - Loader에 의해 물리 메모리의 위치가 결정된다.
     - 로더 : 프로그램을 메모리에 적재시키는 프로그램
   - 컴파일러가 재배치 가능 코드를 생성한 경우에 가능

3. 실행 시간 바인딩

   - 프로그램이 **시작한 후에도 적재된 물리 메모리 상의 주소가 변경**될 수 있는 방식
- CPU가 주소를 참조할 때마다 주소 매핑 테이블을 이용해 바인딩을 점검해야 한다
   - 기준 레지스터, 한계 레지스터와 *[MMU] : Memory Management Unit 라는 하드웨어 지원이 가능해야 한다.

MMU는 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치이다.

MMU기법

- 논리적 주소값에 base register의 값을 더해 물리적 주소를 얻어낸다.
- 기준 레지스터는 해당 프로세스의 메모리 시작 주소를 가지고 있다.
- 프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정한다.
- 문맥 교환으로 CPU에서 수행중인 프로세스가 바뀔 때마다 재배치 레지스터의 값을 해당 프로세스에 해당하는 값으로 재설정

![Image result for limit register](https://worldfullofquestions.files.wordpress.com/2014/07/memory-management-unitmmu.jpg?resize=586%2C419)

**한계 레지스터**를 사용해 프로세스가 자신의 주소 공간을 넘어서는 메모리 참조하려는지를 확인한다.

![Image result for limit register](https://i.stack.imgur.com/zbtch.png)



# 메모리 관리 관련 용어

## 동적 로딩

프로세스가 시작될 때 주소 공간 전체를 메모리에 적재하지 않고 해당 루틴이 불려질 때 **그 루틴만을 메모리에 적재하는 방식**

메모리를 효율적으로 사용할 수 있도록 한다.

## 동적 연결

> 연결(linking) : 소스 코드를 컴파일하여 생성된 목적 파일(object file)과 이미 컴파일된 라이브러리 파일들을 하나로 묶어 하나의 실행 파일을 생성하는 과정

목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 지점까지 지연시키는 기법

정적 연결에서는 작성한 코드와 라이브러리 코드가 합쳐져서 실행 파일이 생성된다.

- 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재해야 함
- 메모리 낭비

동적 연결에서는 **실행 파일에 라이브러리 코드가 포함되지 않으며, 프로그램이 실행되면서 라이브러리 함수를 호출할 때가 되어서야 라이브러리에 대한 연결이 이루어진다.**

- 라이브러리가 적재되 있을 경우 해당 메모리에서 직접 참조
- 그렇지 않으면 라이브러리 파일을 적재 후 실행
- 라이브러리를 한 번만 적재한다.
- 메모리 효율성이 높아진다.

## 중첩

**프로세스의 주소 공간을 분할해 실제 필요한 부분만을 적재하는 기법**

동적 로딩과 개념적으로 비슷하나, 사용 이유는 다르다.

단일 프로세스만을 메모리에 적재하는 환경에서 메모리 용량보다 큰 프로세스를 실행하기 위한 어쩔 수 없는 선택.

## 스와핑

**메모리에 적재된 프로세스의 주소 공간 전체를 스왑 영역(swap area)에 일시적으로 내려놓는 것.**

중기 스케줄러에 의해 스왑 아웃할 프로세스를 선정한다.

스와핑을 통해 다중 프로그래밍의 정도를 조절할 수 있다.

컴파일 타임 바인딩 / 로드 타임 바인딩 방식에서는 스왑 아웃된 프로세스가 다시 스왑 인 될 때 원래 존재하던 메모리 위치로 다시 적재되어야 한다. 

반면, 런타임 바인딩 기법에서는 추후 빈 메모리 영역 아무 곳에나 프로세스를 적재할 수 있다.

![Image result for swap out swap in](https://i2.wp.com/zitoc.com/wp-content/uploads/2019/02/Swapping.png?fit=569%2C429&ssl=1)

# 물리적 메모리의 할당 방식

물리적 메모리는 OS영역과 user process 영역으로 나뉘어 사용된다.

**사용자 프로세스 영역의 관리 방법**

- 연속 할당 방식
  - 물리적 메모리의 연속적인 공간에 프로세스를 적재하는 방식
  - 고정 분할 방식
    - 물리적 메모리를 고정 크기의 분할로 나누어 두는 방식
  - 가변 분할 방식
    - 프로그램 실행, 종료 순서에 따라 분할을 관리하는 방식
- 불연속 할당 방식
  - 하나의 프로세스를 물리적 메모리의 여러 영역에 분산 적재하는 방식
  - 페이징 기법
    - 프로세스의 주소공간을 동일한 크기의 페이지로 잘라서 메모리에 페이지 단위로 적재시키는 기법
  - 세그멘테이션 기법
    - 주소 공간을 의미 있는 단위로 나누어 세그먼트 단위로 적재하는 기법
  - 페이지드 세그멘테이션 기법
    - 세그먼트 하나를 다수의 페이지로 구성하는 기법

## 연속 할당 방식

물리적 메모리의 연속적인 공간에 프로세스를 적재하는 방식

### 고정 분할 방식

물리 메모리를 주어진 개수만큼의 영구적 분할로 나누어 각 분할에 하나의 프로세스를 적재해 실행시킬 수 있게 한다.

**하나의 분할에는 하나의 프로그램만을 적재할 수 있다.**

- 동시에 메모리에 적재할 수 있는 프로그램의 수가 고정되어 있다
- 수행 가능한 프로그램의 최대 크기가 제한된다.

**외부 단편화 / 내부 단편화가 발생할 수 있다.**

> 외부 단편화 : 프로그램의 크기보다 파티션의 크기가 작은 경우 적재하지 못해서 발생하는 메모리 공간
>
> 내부 단편화 : 프로그램의 크기보다 파티션의 크기가 큰 경우 파티션에 적재하고 남는 메모리 공간
>
> - 내부 단편화보다 작은 크기의 프로그램이 있어도 적재되지 못한다. 메모리 낭비

### 가변 분할 방식

메모리에 적재되는 프로그램의 크기에 따라 파티션의 크기와 개수가 동적으로 변하는 방식

**내부 단편화는 발생하지 않는다.** 외부 단편화는 발생할 수 있다.

![고정가변분할방식](https://kouzie.github.io/assets/OS/OS_10_8.png)

**동적 메모리 할당 문제**

- 물리적 메모리 내의 가용 공간 중 어떤 위치에 적재할 것인가?
- 프로세스의 주소 공간 전체를 담을 수 있는 가용 공간을 찾아야 한다.

해결 방법

1. 최초 적합 방법 *first-fit* 

   프로세스의 크기보다 큰 가용 공간 중 가장 먼저 찾아지는 곳에 할당하는 방법

   - 시간적 측면에서 효율적

2. 최적 적합 방법 *best-fit*

   프로세스의 크기보다 큰 가용 공간 중 가장 작은 가용 공간을 찾아 할당하는 방법

   - 시간적 오버헤드 발생
   - 다수의 매우 작은 가용 공간이 생성됨
   - 공간적 측면에서 효율적

3. 최악 적합 방법 *worst-fit*

   가용 공간 중 가장 큰 곳에 프로세스를 할당하는 방법

   - 시간적 오버헤드
   - 큰 가용 공간의 소비

**Compaction**

- 프로세스에 의한 사용중인 메모리 영역을 한쪽으로 몰고, 가용 공간들을 다른 한쪽으로 모아서 하나의 큰 가용 공간을 만드는 방법
- **외부 단편화의 해결 방법**
- 메모리 위치 이동시켜야 하므로 **비용이 매우 많이 든다.**
- 실행 시간 바인딩 방식에서만 수행 가능
  - 물리적 메모리 위치를 옮겨야 하므로!

