---
title: "CSAPP(3) - Machine-Level Representation of Programs"
excerpt: "Computer Systems : A Programmer’s Perspective - 3장"

categories:
  - cs
tags:
  - csapp
last_modified_at: 2023-10-18T08:00:00-08:00
---

컴퓨터는 기계 코드를 실행한다.
- 기계 코드는 바이트 시퀀스로 인코딩한 저수준의 연산이다.
  - 데이터 조작, 메모리 관리, 저장 장치에서 데이터 읽고 쓰기, 네트워크 통신 등의 연산

컴파일러는 프로그래밍 언어의 규칙, 대상 머신의 명령어 집합, 운영 체제에 따른 규약에 기반해서 몇 단계에 거쳐 기계 코드를 생성한다.

GCC C 컴파일러는 어셈블리 코드 형식의 출력을 생성한다.
- 어셈블리 코드 : 프로그램에서 개별 명령을 제공하는 기계 코드의 텍스트 표현

GCC는 이후 어셈블러와 링커를 호출하여 어셈블리 코드에서 실행 가능한 기계 코드를 생성한다.

이번 챕터에서는 기계 코드와 인간이 읽을 수 있는 표현인 어셈블리 코드를 살펴본다.

---
고수준 언어는 높은 수준의 추상화를 통해 생산성있고 신뢰할 수 있다. 또한 고수준 언어로 작성한 프로그램은 다수의 다른 머신에서 컴파일되고 실행될 수 있다. 반면 어셈블리 코드는 크게 머신 특정적이다.

그럼 왜 기계어를 배워야 하나?
- 컴파일러의 최적화를 이해할 수 있고 코드의 근본적인 비효율성을 분석할 수 있다.
- 외부 공격 발생 시 취약점 분석하고 막기 위해

# 1. A Historical Perspective
x86이라 불리는 인텔 프로세서 라인은 단일 칩 16비트 마이크로세서에서 부터 시작해서 많은 일들이 있었다는 역사적인 이야기들. 이후 AMD가 등장해서 x86이 호환되는 64비트 칩을 내놨다는 이야기 등.

# 2. Program Encodings

프로그램이 인코딩되는 과정에 대한 내용
- `gcc` 명령은 소스 코드를 실행 가능한 코드로 변경한다.
  1. 전처리기는 매크로 등 처리
  2. 컴파일러는 어셈블리 코드를 생성
  3. 어셈블러는 어셈블리 코드를 이진 목적 코드 파일로 변환
  4. 링커는 목적 코드 파일을 병합하여 최종 실행 코드 파일을 생성

## 2.1. Machine-Level Code
- 머신레벨의 프로그램의 포맷과 행동은 ISA(instruction set architecture)에 따라 정의된다.
  - 대부분은 각 명령이 순차적으로 실행된다.(동시성 수행 시에도 순차 실행을 보장)
- 머신레벨의 메모리 주소는 가상 주소다.
  - 가상 주소란 매우 큰 바이트 배열처럼 보이는 메모리 모델을 제공한다.
  - 메모리 시스템의 실제 구현은 다양한 하드웨어 메모리와 os의 조합으로 이루어진다.

64비트 머신의 가상 주소는 64비트 워드로 표현되는데, 현재 구현에서는 상위 16비트는 0으로 고정되어있다. 때문에 주소는 $2^{48}$ 범위(64테라바이트)까지만 나타낼 수 있다.

단일 머신 명령은 매우 기초적인 연산(레지스터에 있는 두개의 수 덧셈, 메모리와 레지스터 간 데이터 교환, 새로운 명령 주소로 전환 등)이기에 컴파일러는 산술 표현식, 루프, 프로시저 콜과 리턴을 머신 레벨의 명령으로 바꾸는 역할을 한다.

# 3. Data Formats
- 64비트 머신에서는 포인터가 8byte다. 
- 인텔에서는 16비트 데이터 타입을 word라고 했음.
  - 때문에 어셈블리 코드에서 `movq` 명령은 "64비트를 옮겨라"는 뜻이다.

# 4. Accessing Information
- x86-64 cpu는 64비트 를 저장하는 16개의 general-pupose 레지스터 집합을 가진다.
  - `%r`로 시작하는 이름
  - 각 레지스터의 역할에 대한 소개들..

> 아래는 상세 내용이므로 필요할 때 보기..

## 4.1. Operand Specifiers

## 4.2. Data Movement Instructions

## 4.3. Data Movement Example

## 4.4. Pushing and Popping Stack Data

# 5. Archimetic and Logical Operations

## 5.1. Load Effective Address

## 5.2. Unary and Binary Operations

## 5.3. Shift Operations

## 5.4. Discussion

## 5.5. Special Arithmetic Operations

# 6. Control

# 출처
- https://csapp.cs.cmu.edu/   
- 책 "Computer Systems : A Programmer’s Perspective"