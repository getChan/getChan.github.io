---
title: "운영체제(4)-프로세스 관리:man_factory_worker:"
excerpt: "컴퓨터공학을 정리해봅니다."

categories:
  - cs
tags:
  - study
  - computer science
  - os
last_modified_at: 2020-01-16T08:06:00-05:00
---

> 책 `<운영체제와 정보기술의 원리>, 반효경` 을 읽고 정리한 내용입니다
>
> [운영체제(1) - 개요](/cs/OS_1)
>
> [운영체제(2) - 컴퓨터 시스템의 동작 원리](/cs/OS_2)
>
> [운영체제(3) - 인터럽트의 원리](/cs/OS_3)

# 프로세스 개념

프로세스란?

- 수행중인 프로그램
- 프로그램이 메모리에 올라가서 수행되면 프로세스가 된다
- == JOB

![프로세스의 문맥을 구성하는 요소에 대한 이미지 검색결과](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F9927563C5B00FF8D0F9399)

프로세스의 문맥(Context)

- 프로세스의 상태를 담고 있는 정보
- 하드웨어 문맥
  - CPU의 수행 상태를 나타낸다.
  - Program Counter
  - 각종 레지스터에 저장하고 있는 값들
- 프로세스의 주소 공간
  - 코드, 데이터, 스택
- 커널 상의 문맥
  - PCB
  - 커널 스택

# 프로세스의 상태

![프로세스의 문맥을 구성하는 요소에 대한 이미지 검색결과](https://eunhyejung.github.io/assets/contents/content07.PNG)

**실행 Running**

- 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태

**준비 Ready**

- 프로세스가 CPU만 보유하면 명령을 실행할 수 있으나, CPU를 할당받지 못한 상태

**봉쇄 Blocked (Waiting)**  

- 프로세스에게 CPU를 주어도 당장 명령을 실행할 수 없는 상태

생성 New

- 프로세스가 생성 중
- 아직 메모리 획득을 승인받지 못한 상태

완료 Terminated

- 프로세스가 종료 중 
- 프로세스 관련 자료구조를 완전히 정리하지 못한 상태

**문맥 교환 Context Switch**

- 실행시킬 프로세스를 변경하기 위해 원래 수행중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정

CPU 디스패치

- 준비 상태에 있는 프로세스 중 CPU를 할당받을 프로세스를 선택한 후 CPU의 제어권을 넘겨받는 과정

## 상태 변화 예시

1. 프로세스A가 실행 중 I/O 요청
2. 프로세스A를 I/O장치 큐로 보낸다.(blocked)
3. 준비 큐의 프로세스 중 하나인 프로세스B에 CPU를 할당(ready -> running)
4. 프로세스 A의 입출력 작업 완료
5. I/O 컨트롤러는 CPU에게 하드웨어 인터럽트 발생 *"입출력 완료!"*
6. 프로세스 B가 커널 모드로 진입
7. 인터럽트 루틴 수행
   1. 프로세스 A를 I/O 큐에서 빼내 ready queue로 (ready)
   2. I/O장치의 local buffer 내용을 memory로 이동
8. 프로세스 B에게 다시 CPU 할당 *(경우에 따라 준비 큐에 있는 다른 프로세스에게 할당할 수도 있다.)*
9. 프로세스 B를 다시 user mode로

# 프로세스 제어 블록 PCB

**운영 체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스당 유지하는 정보들을 담는 커널 내의 자료구조**

![img](https://t1.daumcdn.net/cfile/tistory/99F6404A5B00FF8D16)

- 프로세스의 상태
  - CPU할당 가능 여부를 결정하기 위해
- 프로그램 카운터 값
  - 다음에 수행할 명령의 위치
- CPU 레지스터
  - CPU연산을 위해 현재 레지스터에 어떤 값을 저장하고 있는지
- CPU 스케줄링 정보
  - 프로세스의 CPU 스케줄링을 위해
- 메모리 관리 정보
  - 플로세스의 메모리 할당을 위해
- 자원 사용 정보
  - 자원 사용 요금 청구 등
- 입출력 상태 정보

# 문맥 교환

**하나의 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정**

1. 프로세스 A가 CPU를 할당받고 실행되던 중 타이머 인터럽트 발생

2. CPU 제어권 OS가 가지고 타이머 인터럽트 처리 루틴 실행

   1. 프로세스 A의 문맥을 A의 PCB에 저장하고(Ready)

   2. 새로운 프로세스 B에게 CPU를 이양(Running)

      이전에 실행했던 B의 문맥을 복원

타이머 인터럽트 뿐만 아니라 실행중이던 프로세스가 Blocked상태가 되면 발생

![img](https://t1.daumcdn.net/cfile/tistory/998D6B3B5B00FF8D09)

프로세스가 실행 상태일 때 시스템 콜이나 인터럽트가 발생하면 CPU의 제어권이 OS에게 넘어와 원래 프로세스를 잠시 멈추고 OS kernel의 코드가 실행된다. 이 경우에도 CPU의 실행 위치 등 프로세스 문맥 중 일부를 PCB에 저장하지만, 문맥 교환은 아니다. CPU 점유하는 프로세스가 다른 user process로 바뀌지 않기 때문. (ex. I/O 완료 인터럽트)

이는 모드 변경만 일어나는 것이고, 문맥 교환은 오버헤드가 훨씬 크다.

# 프로세스 스케줄링 큐

작업 큐 job queue

- 시스템 내의 모든 프로세스를 관리하기 위한 큐
- 프로세스 상태와 무관하다
- 작업 큐에 있는 프로세스는 메모리를 가지고 있지 않을 수도 있다.

준비 큐 ready queue

- CPU를 할당받고 실행되기 위해 기다리고 있는 프로세스의 집합
- 준비 큐에 속한 프로세스는 Ready State

장치 큐 device queue

- 각각의 장치마다 서비스를 기다리며 줄 서 있는 프로세스 큐
- 장치 큐에 속한 프로세스는 Blocked State

작업 큐 ⊃ (장치 큐 ∪ 준비 큐)

큐 헤더는 큐의 가장 앞부분이고, 큐는 각 프로세스의 PCB를 연결 리스트 형태로 줄세워 포인터 형태로 순서를 정하게 된다.

![img](https://t1.daumcdn.net/cfile/tistory/994142455B00FF8D3A)

장치 큐의 프로세스들은 Blocked State에 있다가 해당 장치의 서비스가 완료되면 장치 컨트롤러가 인터럽트를 발생시켜 Ready Queue로 이동하게 된다.

# 스케줄러

**어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 모듈**

장기 스케줄러 == 작업 스케줄러 Job Scheduler

- 어떤 프로세스를 준비 큐에 삽입할지를 결정
- 프로세스에게 **메모리를 할당하는 문제**에 관여
- 시작 상태의 프로세스 중 어떤 프로세스를 준비 큐에 삽입할 것인가를 결정
- 수 분 단위로 호출. 속도가 느려도 된다.
- **메모리에 동시에 올라가 있는 프로세스의 수를 조절한다.**

> 현대의 시분할 시스템에서는 일반적으로 장기 스케줄러가 없다. 프로세스가 시작 상태가 되면 곧바로 프로세스에 메모리를 할당해 준비 큐에 넣게 된다.

단기 스케줄러 ==  CPU 스케줄러

- 준비 큐에 있는 프로세스 중 어떤 프로세스를 CPU 할당할 지 결정
- 어떤 프로세스를 실행 상태로 만들 것인가?
- 시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다.
- ms 이하 단위로 빈번하게 호출된다. 수행 속도가 빨라야 한다

중기 스케줄러 

- 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하는 스케줄러
- **프로세스당 보유 메모리량이 지나치게 적어진 경우 이를 완화하기 위해 일부 프로세스를 메모리에서 디스크로 스왑 아웃하는 역할**
  - Swap out 1순위 : 봉쇄 상태에 있는 프로세스들
  - 2순위 : 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스

중기 스케줄러의 등장으로 프로세스의 상태가 하나 더 추가된다

![img](https://t1.daumcdn.net/cfile/tistory/99F0C23B5B00FF8D11)

**중지 상태 suspended, stopped**

- 외부적인 이유로 프로세스의 수행이 정지된 상태
- 중지 상태 프로세스는 메모리 자원이 당장 필요하지 않다.
- 메모리를 통째로 빼앗아 디스크로 스왑 아웃

중지 준비 상태 suspended ready

- 준비 상태에 있던 프로세스가 중기 스케줄러에 의해 디스크로 스왑 아웃되는 경우

중지 봉쇄 상태 suspended blocked

- 봉쇄 상태에 있던 프로세스가 중기 스케줄러에 의해 스왑 아웃
- 봉쇄 조건을 만족하면 중지 준비 상태로 변화한다

# 프로세스의 생성

시스템 부팅 후 최초의 프로세스는 운영체제가 직접 생성한다.

그 다음부터는 이미 존재하는 프로세스가 **다른 프로세스를 복제 생성**하게 된다.

부모 프로세스

- 프로세스를 생성한 프로세스

자식 프로세스

- 새롭게 생성된 프로세스



생성된 프로세스가 자원을 획득하는 방법

- 운영 체제로부터 직접 자원을 할당받는다
- 부모 프로세스와 자원을 공유해서 사용한다

프로세스 수행 모델

- 부모와 자식이 공존하며 수행하는 모델
  - 서로 CPU를 차지하기 위해 경쟁
- 자식이 종료될 때까지 부모가 기다리는 모델
  - 자식이 종료되고 나서 부모 프로세스가 준비 상태가 된다

프로세스가 생성되면 자신만의 독자적인 주소 공간을 갖는다.

- 처음 자식 프로세의 주소 공간을 생성할 때는 부모 프로세스의 주소 공간 내용을 그대로 복사해서 생성
- 자식 프로세스가 다른 프로그램을 수행하기 위해서는 생성된 주소 공간 위에 새로운 프로그램의 주소공간을 덮어 씌워 실행하게 된다.

## UNIX의 예

`fork()` 시스템 콜

- 자식 프로세스를 생성할 떄 부모 프로세스의 내용을 그대로 복제 생성
- 프로세스 id는 제외
- 주소 공간은 따로 갖는다. 주소 공간 내의 내용은 동일하다

`exec()` 시스템 콜

- 새로운 프로그램으로 주소 공간의 내용을 덮어씌운다.

## 프로세스 종료

- 자발적 종료
  - 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알리는 방법.
  - `exit()` 시스템 콜을 통해 이루어진다. 프로그램 종료되는 지점에 컴파일러가 자동으로 삽입한다.
  
- 비자발적 종료
  - 부모 프로세스가 자식 프로세스의 수행을 강제로 종료
  - `abort()` 함수를 통해 이루어진다. 
  
  1. 자식 프로세스가 할당 자원의 한계치를 넘어서는 자원을 요구할 때
  2. 자식 프로세스에게 할당된 작업이 더이상 필요 없을 때
  3. 부모 프로세스가 종료(exit)되는 경우

종료되는 부모 프로세스의 자식 프로세스를 계속 실행하려면?

- 종료되지 않을 다른 부모 프로세스에게 자식 프로세스를 입양보낸다

## 자식 프로세스 생성 과정

1. 프로세스 A 가 `fork()`를 호출
2. CPU 제어권이 커널에게 주어진다
3. 커널은 `fork()`를 호출한 프로세스 A를 복제해 자식 프로세스 AA생성
4. AA는 A와 모든 문맥을 동일하게 가지고 있다.

부모 A와 똑같은 기억을 가진 **복제인간 AA**

AA는 자신이 A라고 생각한다 ㅎㅎ

그렇다면 어떻게 복제본을 식별할 수 있나?

- 원본은 `fork()`의 리턴값이 양수

- 복제본은 0을 리턴해준다.

- ```c
  main()
  {
      if (fork() == 0) // this is child
          printf("Hello I am child")
      else // this is parent
          printf("Hello, I am Parent")
  }
  ```



`exec()`

- 주소 공간을 새로운 프로그램으로 덮어씌운 후 처음부터 실행
- 새로운 프로그램을 수행시키기 위해서는 `fork()`를 통해 기존 프로세스 복제 후
- `exec()`을 통해 새로운 프로세스를 자식 프로세스의 주소 공간에 덮어씌운다.

`fork(), exec(), exit(), wait()`은 모두 특권 명령

- `wait()` 
  - 자식 프로세의 종료를 기다리며 부모 프로세스를 봉쇄 상태로 만든다
  - 부모와 자식 프로세스간 동기화를 가능하게 함
  - 일반적인 봉쇄 상태(자원을 기다리며 줄 서있는 것) 아니고 자식 프로세스의 종료를 기다리며 수면 상태에 머무른다.

# 프로세스 간 협력

프로세스는 각자 독립적인 주소 공간을 가지며 다른 프로세스의 주소 공간을 참조하는 것은 허용되지 않는다. 따라서 다른 프로세스의 수행에 영향을 미칠 수 없다.

부모 프로세스가 자식 프로세스를 생성할 때도 자식 프로세스의 생성이 완료되면 **각자 자신의 독자적인 주소 공간을 참조해 코드를 수행하기 때문에 독립적인 관계**가 된다.

때때로 정보 공유 등 프로세스 간 협력이 필요할 때가 있다.

## **IPC**  Inter-Process Communication

**하나의 컴퓨터 안에서 실행중인 서로 다른 프로세스 간에 발생하는 통신**

**프로세스 간 통신**과 **동기화**를 이루기 위한 매커니즘

### **메세지 전달 Message Passing** 방식

**프로세스 간 공유 변수를 사용하지 않고 메시지를 주고받으며 통신**

- 메세지를 직접 전달할 수 없다. 시스템 콜로 커널이 전달 역할을 함
- `send(message) / receive(message)`

![img](https://t1.daumcdn.net/cfile/tistory/99E6A14C5B00FF8D0A)

직접 통신

- 메세지 전송 대상이 다른 프로세스
- `send(P, message)` : P에게 메세지 전달해
- 커뮤니케이션 링크 특성
  - 링크는 자동적으로 생성된다.
  - 하나의 링크는 한 쌍의 프로세스에게 할당된다
  - 각 쌍의 프로세스에게 하나의 링크만이 존재

간접 통신

- 메세지 전송 대상이 메일 박스(port)
- 메일 박스를 공유하는 프로세스 간 통신
- `send(A, message)` : A라는 메일박스에게 메세지 전달해
- 하나의 링크가 여러 프로세스에게 할당될 수 있다
- 각 프로세스의 쌍은 여러 링크를 서로 공유할 수 있다
- 메세지 받는 프로세스의 식별을 위해
  - 2개의 프로세스에게만 링크를 할당하는 방법
  - 링크에 대한 `receive()` 연산을 매 시점 하나의 프로세스만 수행하는 방법
  - 시스템이 메시지 수신자를 결정해 메세지 받은 수신자를 송신자에게 통지하는 방법

### **공유 메모리 Shared Memory** 방식

![img](https://t1.daumcdn.net/cfile/tistory/998B0C3E5B00FF8D16)

**프로세스들이 주소 공간의 일부를 공유한다.**

- 시스템 콜을 통해 서로 다른 프로세스들이 주소 공간 중 일부를 공유할 수 있도록 한다
- 여러 프로세스가 읽고 쓸 수 있다.
- 실제 구현은 프로세스 A와 B가 주소 공간을 독자적으로 갖지만, 공유 메모리 주소 영역에 대해서는 A,B 주소 공간을 동일한 물리적 메모리로 매핑하게 된다.
- 프로세스 간 통신이 수월하다
- 데이터 일관성 문제가 유발될 수 있다.
  - 커널이 책임지지 않는다. 프로세스들끼리 직접 동기화해야 한다.

