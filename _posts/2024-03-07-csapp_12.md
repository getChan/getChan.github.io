---
title: "CSAPP(12) - Concurrent Programming"
excerpt: "Computer Systems : A Programmer’s Perspective - 12장"

categories:
  - cs
tags:
  - csapp
last_modified_at: 2024-03-07T08:00:00-08:00
---

동시성은 여러 레벨의 컴퓨터 시스템에서 나타난다. 
- 하드웨어 예외 핸들러, 프로세스, 리눅스 시그널 핸들러 등
- 지금까지는 os 커널이 주로 처리했지만, 응용 프로그램에서도 중요하다.
  - 느린 입출력 장치에 접근할 때 다른 프로세스가 CPU를 사용할 수 있다.
  - 유저와 상호작용 시 여러 태스크를 동시에 처리한다.
    - 유저가 액션할 때마다 별도의 동시 논리 흐름이 생성된다.
  - 작업을 연기하여 지연시간을 감소시킬 수 있다.
    - 동적 할당자는 각각의 `free`명령을 연기하여 한번에 처리한다.
  - 여러 네트워크 클라이언트를 제공한다. 
    - 동시성 서버는 각 클라이언트별로 별도의 논리 흐름을 생성한다.
  - 멀티 코어 머신에서 병렬 연산

현대 os는 동시성 프로그램을 만들기 위한 3가지의 기본 접근방식을 제공한다.
- Processes
  - 각 논리 제어 흐름은 커널에 의해 계획되고 유지된다. 
  - 프로세스는 별도의 가상 주소 공간을 갖기에, 논리 흐름간 통신하려면 inter-process communication(IPC) 를 사용해야 한다.
- I/O muiltiplexing
  - 애플리케이션이 단일 프로세스에서 명시적으로 자신의 논리 흐름을 계획한다.
  - 상태 머신으로 모델링되었다.
    - 파일 서술자에 도착하는 데이터의 결과에 따라 상태가 전환한다.
  - 프로그램이 단일 프로세스이므로 모든 흐름은 같은 주소 공간을 공유한다.
- Threads
  - 단일 프로세스에서 실행되고 커널에 의해 계획되는 논리 흐름.
  - 프로세스처럼 커널에 의해 계획됨 + 입출력 멀티플렉싱처럼 동일한 가상 주소 공간을 사용함.

# 1. Concurrent Programming with Processes
`fork`, `exec`, `waitpid` 함수를 이용하여 동시성 프로그램을 쉽게 만들 수 있다.
- 동시성 서버는 부모 프로세스에서 클라이언트 연결 요청을 받아서 각 클라이언트별로 자식 프로세스를 만든다.


1. [Server accepts connection request from client](https://csapp.cs.cmu.edu/3e/ics3/conc/conc1.pdf)
2. [Server forks a child process to service the client](https://csapp.cs.cmu.edu/3e/ics3/conc/conc2.pdf)
   1. 부모와 자식 프로세스가 동일한 서술자를 가지므로 부모는 연결된 서술자를 닫아야 한다. 
3. [Server accepts another connection request](https://csapp.cs.cmu.edu/3e/ics3/conc/conc3.pdf)
4. [Server forks another child to service the new client.](https://csapp.cs.cmu.edu/3e/ics3/conc/conc4.pdf)

## 1.1. A concurrent Server Based on Process
- 서버는 오랫동안 실행된다. 때문에 좀비 자식 프로세스를 회수할 SIGCHLD 핸들러를 포함해야 한다.
- 부모와 자식 프로세스는 각자의 `connfd`를 닫아야 한다.
- 소켓의 파일 테이블 엔트리 내 참조 카운트 때문에, 클라이언트의 커넥션은 부모와 자식 모두의 `connfd`가 닫힐 때까지 종료되지 않는다.

```c
#include "csaap.h"
void echo(int connfd);

void sigchld_handler(int sig)
{
  while (waitpid(-1, 9, WHOHANG) > 0)
    ;
  return;
}

int main(int argc, char **argv)
{
  int listenfd, connfd;
  socklen_t clientlen;
  struct sockaddr_storage clientaddr;
  
  if (argc != 2) {
    fprintf(stderr, "usage: %s <port>\n", argv[0]);
    exit(0);
  }

  Signal(SIGCHLD, sigchld_handler);
  listenfd = Open_listenfd(argv[1]); // 인자로 받은 포트로 listen

  while(1) {
    clientlen = sizeof(struct sockaddr_storage);
    connfd = Accept(listenfd, (SA *) &clientaddr, &clientlen);
    if (Fork() == 0) {
      Close(listenfd); // 자식은 listen 소켓을 닫는다
      echo(connfd);    // 자식은 클라이언트에게 서비스한다.
      Close(connfd);   // 자식은 클라이언트와의 커넥션을 닫는다.
      exit(0);         // 자식 exit
    }
    Close(connfd);     // 부모는 연결된 소켓을 닫는다. (중요!)
  }
}
```

## 1.2. Pros and Cons of Processes
프로세스는 부모 자식 간 공유하는 상태 정보가 명료하다.
- 파일 테이블은 공유되고 유저 주소 공간은 공유되지 않는다.
- 프로세스 간 별도의 주소 공간을 가진다
  - 장점 : 메모리 공간을 침범하지 않는다.
  - 단점
    - 상태 정보를 공유하기 위해서는 명시적인 IPC(inter-process communication)이 필요하다.
    - 느리다. 프로세스 제어와 IPC의 오버헤드가 크기 때문.

#