---
title: "CSAPP(8) - Exceptional Control Flow"
excerpt: "Computer Systems : A Programmer’s Perspective - 8장"

categories:
  - cs
tags:
  - csapp
last_modified_at: 2023-12-13T08:00:00-08:00
---

- 제어 흐름의 가장 간단한 종류는 "smooth" 시퀀스다. 인접한 메모리에 있는 명령어들을 순차적으로 실행하는 것. 
- 인접하지 않은 명령어를 수행해야 할 때도 있다. jump, call, return 등. 
- 시스템은 프로그램 내에서 일어나지 않는 변화에 대해서도 반응할 수 있어야 한다. 
  - 하드웨어 타이머, 패킷이 도착해서 메모리에 올려야 할 때, 디스크에 데이터를 요청하고 기다릴 때 등.
  - 앞으로 이를 exceptional contol flow(ECF)라 부르겠다.
  - 하드웨어 수준에서는 하드웨어 트리거에 의해 이벤트가 감지되어 예외 핸들러에게 제어를 전달하고
  - OS수준에서는 커널이 context switching으로 한 유저 프로세스의 제어를 다른 유저 프로세스로 전달한다.
  - 애플리케이션 수준에서는 한 프로세스가 다른 프로세스에 signal을 보낼 수 있다. 시그널은 수신자의 시그널 핸들러로 제어를 전달한다.
  - 개별 프로그램은 에러 발생 시 다른 함수의 임의 위치로 점프할 수 있다.

# 1. Exceptions
- 예외는 ECF중 하나로 일부는 하드웨어, 일부는 OS에 구현되어 있다.
- 일부는 하드웨어에 구현되어 있어서 시스템에 따라 디테일이 다르다. 다만 기본 아이디어는 동일하다.

![](https://img-blog.csdnimg.cn/bf716a4ec38049dca5755551ee5424af.png)
- 이벤트는 가상 메모리 페이지 폴트, 산술 오버플로, divide by zero와 같이 현재 명령어 실행과 관계있을 수도 있고
- 시스템 타이머, 입출력 요청 완료와 같이 관계없을수도 있다.

프로세서가 이벤트 발생을 감지하면 exception table을 통해서 exception handler를 호출한다. 예외 핸들러가 처리를 끝내면 아래 세 가지 중 하나를 한다.
1. 핸들러는 제어를 이벤트 발생 시점의 명령어로 반환한다.
2. 핸들러는 제어를 이벤트 발생 시점의 명령어 다음 명령어로 반환한다.
3. 핸들러는 프로그램을 중단한다.

## 1.1. Exception handling
각 예외는 고유의 exception number를 갖는다.
- 몇 개는 프로세서 설계자가 지정하고
  - divide by zero, 페이지 폴트, 메모리 접근 위반, 산술 오버플로
- 나머지는 커널 설계자가 지정한다
  - 시스템 콜, 외부 입출력 장치 시그널

시스템 부트 시점에 os는 exception table이라 하는 점프 테이블을 할당하고 초기화한다. 

런타임에 프로세서는 이벤트를 감지하고 예외 번호 k를 결정한다. 프로세서는 예외 테이블을 통해 핸들러를 간접 프로시저 호출하여 예외를 트리거한다.
- k는 예외 테이블의 인덱스다. 테이블의 시작 주소는 exception table base register에 존재한다.

예외는 프로시저 호출과 유사하나 다르다.
- 프로시저 호출은 스택에 반환 주소를 넣지만, 예외는 현재 명령 혹은 다음 명령을 반환한다.
- 예외는 스택에 추가 프로세서 상태를 넣는다.
- 제어가 유저 프로그램에서 커널로 전달될 때는 커널의 스택에 푸시된다.
- 예외 핸들러는 커널 모드에서 실행된다. 시스템 자원에 완전히 접근 가능하다.

## 1.2. Classes of Exceptions
예외는 4개로 구분된다. *interrupts, traps, faults, aborts*

class | Cause| Async/Sync | Return behavior
----|----|----|---
인터럽트 | 입출력 장치의 시그널 | 비동기 | 언제나 다음 명령어를 반환
트랩 | 의도적인 예외 | 동기 | 언제나 다음 명령어를 반환
폴트 | 잠재적으로 회복가능한 에러 | 동기 | 아마도 현재 명령어를 반환
중단 | 회복불가능한 에러 | 동기 | 절대 반환하지 않음


**인터럽트**
- 입출력장치의 시그널로 비동기적으로 발생한다.
- 하드웨어 인터럽트는 비동기다. 특정 명령의 실행으로 발생하지 않기 때문.
- 인터럽트의 예외 핸들러는 interrupt handler라 한다.
- 핸들러는 제어를 다음 명령어로 반환한다. 프로그램은 마치 인터럽트가 발생하지 않았던 것처럼 실행을 계속한다.

![](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220210215042.png)

**트랩과 시스템 콜**
- 트랩은 의도적인 예외다. 
- 트랩의 주요 쓰임새는 유저 프로그램과 커널 간 인터페이스를 제공하는 것이다.(시스템 콜)
- 프로세서는 커널에 제어된 접근을 허용하기 위해 `syscall n` 명령어를 제공한다.
- `syscall` 명령은 예외 핸들러에 트랩을 발생시켜서 적절한 커널 루틴을 호출한다. 
- 프로그래머 관점에서 시스템 콜은 함수 호출과 동일하다.
  - 다만 내부적으로 커널 모드에서 실행된다.

![](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220210221251.png)

**폴트**
- 폴트는 핸들러가 복구할 수 있는 에러의 결과다. 
- 폴트가 발생하면 프로세스는 제어를 폴트 핸들러로 넘긴다. 
  - 핸들러가 에러를 고칠 수 있으면 폴팅 명령으로 제어를 반환한다.
  - 그렇지 않으면 핸들러는 커널의 중지 루틴으로 반환한다.
- eg. 페이지 폴트 발생 시 페이지 폴트 핸들러는 적절한 페이지를 디스크에서 메모리로 적재한다. 이후 제어를 폴트 발생 명령어로 반환한다.

![](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220210222537.png)

**중단**
- 복구 불가능한 에러의 결과
- 제어를 애플리케이션에 반환하지 않는다.


![](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220210223641.png)

## 1.3. Exceptions in Linux/x86-64 Systems
Exception number | Description | Exception class
---- | ---- | ----
0 | Divide error (Floating exceptions) | Fault (not recover)
13 | General protection faults (Segmentation faults) | Fault (not recover)
14 | Page fault | Fault (recover)
18 | Machine check | Abort
32-255 | OS-defined exceptions | Interrupt or trap

# 2. Processes