---
title: "C - 메모리"
excerpt: "메모리"

categories:
  - cs
tags:
  - c
  - cs
last_modified_at: 2021-11-09T08:06:00-05:00
---

# 메모리의 종류

아래 영역들은 물리적으로 같은 메모리

- 스택 섹션
- 힙 섹션
- 데이터 섹션, 코드 섹션
  - 특정 코드 및 데이터용으로 고정

힙 메모리가 범용적인 기본 형태

스택은 특별한 용도를 가진 메모리

- 프로그램의 쓰레드마다 특별한 용도에 사용하라고 별도로 떼어준 것

CPU에도 **저장 공간**이 있음

- 레지스터 : CPU에서만 사용하는 **고속** 저장 공간

# 스택 메모리

함수 호출 시 스택에 어떻게 들어가는지는 함수 호출 규약에 따라 달라짐 **calling convention**

https://getchan.github.io/cs/c_stack_memory/

# 레지스터

메모리는 아니다. CPU 전용 휘발성 데이터 저장 공간.

메모리에 읽고 쓰는게 상대적으로 느려서 레지스터를 사용한다

왜 메모리는 느릴까?

- Bus를 타야 하기에 느림
- 대부분 메모리는 DRAM임
  - 가격이 쌈. 기록된 내용을 유지하기 위해 주기적으로 정보를 다시 써야 함. 따라서 시간 소모 큼
- SRAM은 빠르지만 비싸다

CPU 속도 개선을 위해 적은 용량의 SRAM을 **CPU 안**에 넣어버림. 그것이 레지스터.

## 명령 실행 패턴

1. 변수의 값을 메모리 어딘가에 저장
2. 그 변수의 값을 읽어와 **레지스터**에 저장
3. 레지스터에 저장된 값을 가지고 계산한 뒤, 계산 결과도 레지스터에 저장
4. 그 결과를 다시 메모리에 저장
5. 다시 그 결과를 사용해서 계산하면 레지스터에 또 복사

CPU연산은 대부분 레지스터를 거친다.

## `register` 키워드

레지스터 사용을 '요청'하는 예  - 컴파일러에서 사용 안 할 수도. 대부분 사용 안 함..

```c
int num;
register size_t i;
num = 0;
for (i = 0; i < 1000; ++i) {
  num += i;
}
```

레지스터 변수의 제약

1. 변수의 주소를 구할 수 없음

   ```c
   register int num = 10;
   int* p;
   p = &num; // 컴파일 오류
   ```

2. 레지스터 배열을 포인터로 사용 불가

   ```c
   register int nums[10];
   int* p;
   p = &nums; // 컴파일 오류
   p = &nums[0]; // 컴파일 오류
   ```

3. 블록 범위에서만 사용 가능
   전역 변수에는 사용할 수 없음

   ```c
   register int g_num; // 컴파일 에러
   int main(void){
     return 0;
   }
   ```

요즘엔 보통 컴파일러가 배포 모드에서 알아서 최적화함. 더 이상 프로그래머가 수동으로 사용하지 않는 키워드

# 힙 메모리

스택 메모리의 단점

1. 수명
   - 지역 변수의 수명은 함수가 끝날 때까지
   - 전역 변수나 `static` 변수는 프로그램 실행 내내
   - 중간 정도의 수명을 가질 수는 없나?
2. 크기
   - 스택 메모리의 크기는 컴파일 시에 결정하므로 크게 못 잡음
   - 엄청 큰 데이터를 처리해야 할 경우 스택 메모리에 못 넣음

힙 메모리

- 범용적 메모리
- 스택처럼 특정 용도로 할당한 것이 아님
- CPU가 자동적으로 메모리 관리를 안 해줌
- 프로그래머가 원할 때 원하는 만큼 메모리를 할당받아 원할 때 반납(해제)할 수 있음

장점

- 용량 제한이 없음 : 컴퓨터에 남아있는 메모리만큼 사용 가능
- 프로그래머가 데이터의 수명을 직접 제어

단점

- 할당받은 메모리를 직접 해제 안 하면 누구도 그 메모리를 쓸 수 없음
- 빌려간 쪽에서 메모리 주소 잃어버리면 메모리 누수 발생
- 스택에 비해 할당 / 해제 속도가 느림
  - 스택은 오프셋 개념 vs 힙은 사용/비사용 중인 메모리 관리 개념
  - 메모리 공간에 구멍이 생겨 효율적인 메모리 관리가 어려움

정적 메모리 vs 동적 메모리

- **스택 메모리는 정적 메모리**
  - 이미 공간이 따로 할당되어 있음
  - 할당/해제가 자동으로 관리되도록 컴파일됨
  - 오프셋 개념으로 정확히 몇 바이트씩 사용해랴 하는지 컴파일시 결정
- **힙 메모리는 동적 메모리**
  - 런타임에 크기와 할당/해제 시기가 결정됨

# 동적 메모리

메모리 할당

- 힙 관리자에게 메모리를 x바이트만큼 달라고 요청
  - 연속되는 x만큼의 메모리를 찾아서 반환
- 시작 주소값을 반환하므로 반환 데이터형은 포인터

메모리 사용

- 할당받은 메모리를 원하는대로 사용

메모리 반납 / 해제

- 힙 관리자에게 반납 요청
  - 관리자는 메모리 주소를 아무도 사용하지 않는 상태로 바꿈

## 메모리 할당 함수

```c
void* malloc(size_t size);
```

- memory allocation
- `size` 바이트 만큼의 메모리를 반환해줌
- `void*`형으로 반환
- 반환된 메모리에 있는 값은 쓰레기 값
  - 초기화 안 해줌
- 메모리가 더 이상 없다거나 해서 실패하면 `NULL` 반환

# 출처

POCU 아카데미 'C 언매니지드 프로그래밍'



