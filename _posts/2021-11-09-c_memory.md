---
title: "C - 메모리"
excerpt: "메모리"

categories:
  - cs
tags:
  - c
  - cs
last_modified_at: 2021-11-09T08:06:00-05:00
---

# 메모리의 종류

아래 영역들은 물리적으로 같은 메모리

- 스택 섹션
- 힙 섹션
- 데이터 섹션, 코드 섹션
  - 특정 코드 및 데이터용으로 고정

힙 메모리가 범용적인 기본 형태

스택은 특별한 용도를 가진 메모리

- 프로그램의 쓰레드마다 특별한 용도에 사용하라고 별도로 떼어준 것

CPU에도 **저장 공간**이 있음

- 레지스터 : CPU에서만 사용하는 **고속** 저장 공간

# 스택 메모리

함수 호출 시 스택에 어떻게 들어가는지는 함수 호출 규약에 따라 달라짐 **calling convention**

https://getchan.github.io/cs/c_stack_memory/

# 레지스터

메모리는 아니다. CPU 전용 휘발성 데이터 저장 공간.

메모리에 읽고 쓰는게 상대적으로 느려서 레지스터를 사용한다

왜 메모리는 느릴까?

- Bus를 타야 하기에 느림
- 대부분 메모리는 DRAM임
  - 가격이 쌈. 기록된 내용을 유지하기 위해 주기적으로 정보를 다시 써야 함. 따라서 시간 소모 큼
- SRAM은 빠르지만 비싸다

CPU 속도 개선을 위해 적은 용량의 SRAM을 **CPU 안**에 넣어버림. 그것이 레지스터.

## 명령 실행 패턴

1. 변수의 값을 메모리 어딘가에 저장
2. 그 변수의 값을 읽어와 **레지스터**에 저장
3. 레지스터에 저장된 값을 가지고 계산한 뒤, 계산 결과도 레지스터에 저장
4. 그 결과를 다시 메모리에 저장
5. 다시 그 결과를 사용해서 계산하면 레지스터에 또 복사

CPU연산은 대부분 레지스터를 거친다.

## `register` 키워드

레지스터 사용을 '요청'하는 예  - 컴파일러에서 사용 안 할 수도. 대부분 사용 안 함..

```c
int num;
register size_t i;
num = 0;
for (i = 0; i < 1000; ++i) {
  num += i;
}
```

레지스터 변수의 제약

1. 변수의 주소를 구할 수 없음

   ```c
   register int num = 10;
   int* p;
   p = &num; // 컴파일 오류
   ```

2. 레지스터 배열을 포인터로 사용 불가

   ```c
   register int nums[10];
   int* p;
   p = &nums; // 컴파일 오류
   p = &nums[0]; // 컴파일 오류
   ```

3. 블록 범위에서만 사용 가능
   전역 변수에는 사용할 수 없음

   ```c
   register int g_num; // 컴파일 에러
   int main(void){
     return 0;
   }
   ```

요즘엔 보통 컴파일러가 배포 모드에서 알아서 최적화함. 더 이상 프로그래머가 수동으로 사용하지 않는 키워드



